package game;

import javax.print.attribute.HashAttributeSet;
import java.util.*;
import java.util.zip.CheckedOutputStream;

public class Algorithms {
    private static Random r = new Random();
    // random hamiltonian cycle generated by hand (not possible to calculate for 18x12 field since best runtime is 2^n)
    public static int[] randomH = new int[]{1,1,4,2,4,1,1,3,3,1,4,4,1,3,3,1,4,4,1,1,3,2,3,1,1,4,4,1,3,3,1,4,4,4,1,3,3,3,1,4,4,1,3,3,1,1,1,4,2,2,4,
            4,2,2,4,1,1,1,3,3,1,4,4,4,2,2,2,2,2,3,2,2,3,2,2,2,2,2,2,2,4,1,1,1,1,1,1,4,1,1,4,1,1,1,1,1,1,4,2,2,2,2,2,2,2,3,2,4,2,3,3,2,2,2,2,2,2,3,3,2,4,4,4,1,1,1,1,1,1,4,4,1,1,1,1,1,1,1,1,1,
            1,4,2,2,2,4,1,1,1,4,2,2,2,2,3,3,2,4,4,2,3,3,2,4,4,2,3,3,2,2,2,2,2,4,1,1,1,1,4,2,2,2,2,2,3,3,3,1,1,1,3,2,2,2,2,4,4,4,4,2,2,3,1,3,2,3,1,3,2,3,3,3,3,3,3,3};
    private static ArrayList<Coordinate> coords = new ArrayList<>();


    // utility class used for A* search
    private static class PQPair implements Comparable<PQPair> {
        Coordinate c;
        int value;
        ArrayList<Coordinate> positions;
        HashSet<Coordinate> visited;
        HashMap<Coordinate, Coordinate> map;
        PQPair(Coordinate c, int value, ArrayList<Coordinate> positions, HashSet<Coordinate> visited, HashMap<Coordinate, Coordinate> map) {
            this.c = c;
            this.value = value;
            this.positions = positions;
            this.visited = visited;
            this.map = map;
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;
            PQPair pqPair = (PQPair) o;
            return value == pqPair.value &&
                    c.equals(pqPair.c);
        }

        @Override
        public int hashCode() {
            return Objects.hash(c, value);
        }

        @Override
        public int compareTo(PQPair other) {
            return this.value - other.value;
        }
    }

    // used for testing purposes
    //public static void main(String[] args) { }

    /**
     * Creates a list of coordinates based on randomH
     */
    public static void buildCords() {
        coords.clear();
        Coordinate cur = new Coordinate(0,0);
        coords.add(cur);
        for (int i = 0; i < randomH.length; i++) {
            cur = getCordFromMove(cur, randomH[i]);
            coords.add(cur);
        }
    }

    /**
     *
     * @param index in the hamiltonian cycle
     * @param food is the position of the food
     * @param positions are the positions of the snake
     * @return the move and the index to which you should skip. Returns {-1,-1} if no cut is possible
     */
    public static int[] getShortcutMove(int index, Coordinate food, ArrayList<Coordinate> positions) {
        Coordinate c = coords.get(index);
        ArrayList<Coordinate> n = getNeighbors(c);
        if (n.contains(food)) {
            int move = move(c.getX(), c.getY(), food.getX(), food.getY());
            for (int i = 0; i < coords.size(); i++){
                if (coords.get(i).equals(food)) {
                    index = i;
                    break;
                }
            }
            int size = positions.size();
            int idx = index;

            // check if we can cut without hitting the snake
            while (size > 0) {
                if (positions.contains(coords.get((++idx)%coords.size()))) {
                    return new int[]{-1,-1};
                }
                size--;
            }

            return new int[]{move, index};
        }
        return new int[]{-1,-1};
    }

    /**
     *
     * @param cur is the current coordinate
     * @param move is the move performed
     * @return a coordinate in which snake will end up after specified move. Returns null if move is invalid. Valid moves are 1,2,3,4
     */
    private static Coordinate getCordFromMove(Coordinate cur, int move) {
        if (move == 1) {
            return new Coordinate(cur.getX()+1, cur.getY());
        } else if (move == 2){
            return new Coordinate(cur.getX()-1, cur.getY());
        } else if (move == 3){
            return new Coordinate(cur.getX(), cur.getY()-1);
        } else if (move == 4){
            return new Coordinate(cur.getX(), cur.getY()+1);
        } else {
            return null;
        }
    }


    /**
     *
     * @param x size of the grid
     * @param y size of the grid
     * @param random is used to determine if method should generate a random hamiltonian cycle. Random cycle is generated if random is true
     * @return and in array specifying the moves in hamiltonian cycle
     * Note that this method assumes 0,0 as starting position of the snake
     */
    public static int[] hamiltonianCycle(int x, int y, boolean random){
        Coordinate current = new Coordinate(0,0);
        int currLen = 0;
        Stack<Coordinate> coordinates = new Stack<>();
        return findH(current, currLen, x, y, new int[x*y], coordinates, random);
    }

    /**
     * Note that this method has a condition that any path should lead to the snake being able to access 80% of all the available cells at the end of the path.
     * This condition can be ignored if @param any is true
     * @param positions is a list of coordinates of the snake
     * @param headSnakePos is the position of the head of the snake
     * @param foodPosition is the position of the food
     * @param x size of the grid
     * @param y size of the grid
     * @param max if max is true method will return a max (longest) path to food
     * @param any method will return any path to food regardless if it satisfies the condition. max parameter is still taken into account
     * @return an int array representing the moves in the path that method found. If no path was found, an empty array is returned
     */
    public static int[] aStartSearch(ArrayList<Coordinate> positions, Coordinate headSnakePos, Coordinate foodPosition, int x, int y, boolean max, boolean any) {
        if (positions.isEmpty()) {
            return new int[0];
        }
        PriorityQueue<PQPair> pq = new PriorityQueue<>();
        // start finding longest path max == true
        if (max) {
            pq = new PriorityQueue<>((n1, n2) -> n2.value - n1.value);
        }
        HashSet<Coordinate> visited = new HashSet<>();
        HashMap<Coordinate, Coordinate> map = new HashMap<>();
        map.put(headSnakePos, new Coordinate(-1,-1));
        PQPair p = new PQPair(headSnakePos, 0, positions, visited, new HashMap<>(map));
        pq.add(p);
        boolean found = false;

        while (!pq.isEmpty()) {
            PQPair current = pq.poll();
            if (current.visited.contains(current.c)) {
                continue;
            }
            if (current.c.equals(foodPosition)) {
                // check if can get to 80% of cells
                ArrayList<Coordinate> temp = new ArrayList<>(current.positions);
                temp.add(foodPosition);
                if (numberOfCellsCanReach(current.positions, x, y) <= 0.8 && !any){
                    continue;
                } else {
                    found = true;
                    map = current.map;
                    break;
                }
            }

            current.visited.add(current.c);
            ArrayList<Coordinate> neighbors = getNeighbors(current.c);

            // filter out neighbors
            for (int i = 0; i < neighbors.size(); i++) {
                if (current.positions.contains(neighbors.get(i)) || outOfBounds(x, y, neighbors.get(i).getX(), neighbors.get(i).getY())) {
                    neighbors.remove(neighbors.get(i));
                    i--;
                }
            }

            // add neighbors to pq
            for (Coordinate cor : neighbors) {
                int move = move(current.c.getX(), current.c.getY(), cor.getX(), cor.getY());
                ArrayList<Coordinate> newPositions = new ArrayList<>(current.positions);
                if (!cor.equals(foodPosition)){
                    deleteTail(newPositions);
                }
                addNewHead(move, newPositions);
                if (!current.visited.contains(cor)) {
                    current.map.put(cor, current.c);
                    HashMap<Coordinate,Coordinate> newMap = new HashMap<>(current.map);
                    pq.add(new PQPair(cor, current.value+1 + distance(cor, foodPosition), newPositions, new HashSet<>(current.visited), newMap));
                }
            }
        }

        if (found) {
            Coordinate temp;
            ArrayList<Coordinate> result = new ArrayList<>();
            result.add(foodPosition);
            temp = map.get(foodPosition);
            //loop back trough the path
            while (temp != null && !temp.equals(new Coordinate(-1,-1))) {
                result.add(temp);
                temp = map.get(temp);
            }
            int[] ret = new int[result.size()-1];
            for (int i = 0; i < result.size()-1; i++) {
                Coordinate c1 = result.get(i);
                Coordinate c2 = result.get(i+1);
                ret[result.size() - 2 - i] = move(c2.getX(), c2.getY(), c1.getX(), c1.getY());
            }
            return ret;
        }
        return new int[0];
    }

    // helper method to check how many cells can be reached at the end of the path (as proportion, 1 being 100%).
    private static double numberOfCellsCanReach(ArrayList<Coordinate> positions, int x, int y) {
        if (positions.isEmpty()) {
            return 1;  // if there is no snake
        }
        Queue<Coordinate> pq = new LinkedList<>();
        HashSet<Coordinate> visited = new HashSet<>();
        Coordinate p = positions.get(positions.size()-1);
        pq.add(p);
        while (!pq.isEmpty()) {
            Coordinate current = pq.poll();
            if (visited.contains(current)) {
                continue;
            }
            visited.add(current);
            ArrayList<Coordinate> neighbors = getNeighbors(current);
            for (int i = 0; i < neighbors.size(); i++) {
                if (positions.contains(neighbors.get(i)) || outOfBounds(x, y, neighbors.get(i).getX(), neighbors.get(i).getY())) {
                    neighbors.remove(i);
                    i--;
                }
            }
            for (Coordinate cor : neighbors) {
                if (!visited.contains(cor)) {
                    pq.add(cor);
                }
            }
        }

        double result = (((visited.size()-1) *1.0) / ((x*y)-(positions.size())));
        return result;
    }

    // helper to calculate the distance between two coordinates
    private static int distance(Coordinate c1, Coordinate c2) {
        return c1.getManhattanDistanceTo(c2);
    }

    // method that find a hamiltonian cycle
    private static int[] findH(Coordinate current, int currLen, int x, int y, int[] res, Stack<Coordinate> coordinates, boolean random) {
        if (currLen == (x*y)) {
            System.out.println(Arrays.toString(res));
            return res;
        } else {
            coordinates.push(current);
            ArrayList<Coordinate> neighbors = getNeighbors(current);
            if (currLen + 1 == (x*y) && neighbors.contains(new Coordinate(0,0))) {
                res[currLen] = move(current.getX(), current.getY(), 0, 0);
                return res;
            }
            ArrayList<Coordinate> valid = new ArrayList<>();
            for (Coordinate c : neighbors) {
                if (!outOfBounds(x,y,c.getX(),c.getY()) && !coordinates.contains(c)) {
                    valid.add(c);
                }
            }

            if (valid.size() != 0) {
                if (random){
                    Collections.shuffle(valid);
                }
                // loop trough all valid moves
                for (Coordinate c : valid){
                    res[currLen] = move(current.getX(), current.getY(), c.getX(), c.getY());
                    res = findH(c, currLen + 1, x, y, res, coordinates, random);
                    boolean done = true;
                    for (int i = 0 ; i< res.length; i++){
                        if (res[i] == 0) {
                            done = false;
                        }
                    }
                    if (done) {
                        return res;
                    }
                }
                res[currLen-1] = 0;
            } else {
                // no move found: tack back
                res[--currLen] = 0;
            }
            coordinates.pop();
        }
        return res;
    }

    // 1 right 2 left 3 top 4 bottom
    // return the move
    private static int move(int x1, int y1, int x2, int y2) {
        if (x1 > x2) {
            return 2;
        } else if (x2 > x1) {
            return 1;
        } else if (y1 < y2) {
            return 4;
        } else {
            return 3;
        }
    }
    // check if x or y are outside the grid
    private static boolean outOfBounds(int maxX, int maxY, int x, int y) {
        if (x < 0 || y < 0) {
            return true;
        }
        if (x >= maxX || y >= maxY) {
            return true;
        }

        return false;
    }
    //get all the valid neighbors of the coordinates
    private static ArrayList<Coordinate> getNeighbors(Coordinate curr) {
        ArrayList<Coordinate> res = new ArrayList<>();
        res.add(new Coordinate(curr.getX() + 1, curr.getY()));
        res.add(new Coordinate(curr.getX(), curr.getY() + 1));
        res.add(new Coordinate(curr.getX() - 1, curr.getY()));
        res.add(new Coordinate(curr.getX(), curr.getY() - 1));
        return res;
    }
    // helper method for A* search that moves the head of the snake as search progresses
    private static void addNewHead(int dir, ArrayList<Coordinate> positions){
        Coordinate head = positions.get(positions.size()-1);
        switch(dir){
            case 4:
                positions.add(new Coordinate(head.getX(), head.getY()+1));
                break;
            case 3:
                positions.add(new Coordinate(head.getX(), head.getY()-1));
                break;
            case 2:
                positions.add(new Coordinate(head.getX()-1, head.getY()));
                break;
            case 1:
                positions.add(new Coordinate(head.getX()+1, head.getY()));
        }
    }

    // helper method for A* search that deletes tail of the snake as search progresses
    private static void deleteTail(ArrayList<Coordinate> positions){
        int size = positions.size()-1;
        for(int i = positions.size()-1;i>=0;i--){
            if(size==0){
                positions.remove(i);
            }
            else{
                size--;
            }
        }
    }
}
